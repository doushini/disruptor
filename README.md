# disruptor
this is some samples for disruptor

RingBuffer:用在多线程（不同上下文）间传递数据的buffer，多线程但是无锁，所以快
ringbuffer拥有一个序号，这个序号指向数组中下一个可用的元素
随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环
要找到数组中当前序号指向的元素，可以通过mod操作
没有尾指针。我们只维护了一个指向下一个可用位置的序号。
我们不会删除已经消费的数据，万一有数据没成功消费，那我们还可以重新读，也就是说这些数据一直存放在buffer中，直到新的数据覆盖他们，ringBuffer本身不控制数据是否覆盖
之所以ringbuffer采用这种数据结构，是因为它在可靠消息传递方面有很好的性能，不过它还有一些其他的优点。
首先，因为它是数组，所以要比链表快（数组内元素的内存地址的连续性存储的），而且有一个容易预测的访问模式。
    这是对CPU缓存友好的—也就是说，在硬件级别，数组中的元素是会被预加载的，因此在ringbuffer当中，cpu无需时不时去主存加载数组中的下一个元素。（校对注：因为只要一个元素被加载到缓存行，其他相邻的几个元素也会被加载进同一个缓存行）
其次，你可以为数组预先分配内存，使得数组对象一直存在（除非程序终止）。这就意味着不需要花大量的时间用于垃圾回收。
此外，不像链表那样，需要为每一个添加到其上面的对象创造节点对象—对应的，当删除节点时，需要执行相应的内存清理操作。

当你将Disruptor和基于队列之类的实现进行比较时，事情将变得很有趣。
    队列通常注重维护队列的头尾元素，添加和删除元素等。
    所有的这些我都没有在ringbuffer里提到，这是因为ringbuffer不负责这些事情，我们把这些操作都移到了数据结构（ringbuffer）的外部


